I cannot directly create and send `.txt` files. However, I can provide the entire content formatted in a way that you can easily copy and paste into a text editor (like Notepad, VS Code, Sublime Text, etc.) and then save it as a `.txt` file.

This request is very substantial, requiring 150 questions across 7 distinct Spring areas, each with an easy explanation. Providing "expert" level knowledge through just questions and answers is ambitious, as true expertise comes from hands-on practice, understanding underlying principles, and problem-solving. However, I will provide a comprehensive set of questions designed to cover fundamental to intermediate concepts in each specified area, which will serve as an excellent knowledge base.

Let's break down the 150 questions:

  * **Spring Core:** \~25-30 questions
  * **Spring Boot:** \~25-30 questions
  * **Spring Web (MVC):** \~20-25 questions
  * **Spring Data JPA:** \~20-25 questions
  * **Spring REST:** \~15-20 questions
  * **Spring Security:** \~15-20 questions
  * **Microservices (Spring context):** \~10-15 questions

This totals roughly 150 questions. I will use the requested format:
`[Question Number].) [Question Text]`
`ans.) [Easy Explanation]`
`eg.) [Relevant Example (if applicable)]`

This will be a very long response. Please be aware that generating this many detailed questions and answers will take some time.

-----

Here is the content for your .txt file:

```
1.) What is the Spring Framework?
ans.) The Spring Framework is an open-source, comprehensive, enterprise-level framework for building Java applications. It provides robust infrastructure support for developing various types of applications, including web apps, microservices, and enterprise systems, by handling common tasks like dependency injection, aspect-oriented programming, and transaction management.

2.) What are the key features of Spring Framework?
ans.) Some key features include:
    - Inversion of Control (IoC)/Dependency Injection (DI)
    - Aspect-Oriented Programming (AOP)
    - Spring MVC (for web applications)
    - Spring Data (for database access)
    - Spring Security (for authentication/authorization)
    - Spring Boot (for rapid application development)
    - Transaction Management

3.) What is Inversion of Control (IoC)?
ans.) IoC is a design principle where the control of objects or flow of a program is transferred from the developer to a framework or container. Instead of the developer creating and managing objects, the container creates and manages them.

4.) What is Dependency Injection (DI)?
ans.) DI is a specific implementation of IoC where the dependencies of an object are "injected" (provided) into it by an external entity (the Spring IoC container), rather than the object creating or looking up its dependencies itself. This makes components loosely coupled and easier to test.

5.) What are the different types of Dependency Injection in Spring?
ans.) There are three main types:
    1.  **Constructor Injection:** Dependencies are provided through a class's constructor. This ensures that the object is always in a valid state with all required dependencies.
    2.  **Setter Injection:** Dependencies are provided through setter methods. This is useful for optional dependencies or for components that need to be reconfigured.
    3.  **Field (or Property) Injection:** Dependencies are injected directly into fields using annotations like `@Autowired`. This is convenient but makes testing harder without the Spring container.

6.) What is the Spring IoC Container?
ans.) The Spring IoC container is the core of the Spring Framework. It's responsible for managing the lifecycle of Java objects (beans), from creation and configuration to destruction. It creates objects, wires them together, and manages their entire lifecycle.

7.) What is a `Bean` in Spring?
ans.) In Spring, a "bean" is simply an object that is instantiated, assembled, and managed by the Spring IoC container. They are the fundamental building blocks of a Spring application.

8.) What are the common ways to configure Spring Beans?
ans.) Beans can be configured using:
    1.  **XML-based configuration:** Using `<bean>` tags in an XML file. (Older approach, less common now).
    2.  **Annotation-based configuration:** Using annotations like `@Component`, `@Service`, `@Repository`, `@Controller`, `@Bean`, etc. (Most common).
    3.  **Java-based configuration:** Using `@Configuration` and `@Bean` annotations in Java classes. (Recommended for modern Spring).

9.) Explain `@Autowired` annotation.
ans.) The `@Autowired` annotation is used for automatic dependency injection. Spring automatically finds a matching bean in its IoC container and injects it into the annotated field, constructor, or setter method.
eg.) `class MyService { @Autowired private MyRepository repository; }`

10.) What is `@Component` annotation?
ans.) `@Component` is a generic stereotype annotation indicating that a Java class is a Spring-managed component. It tells Spring to scan this class and register it as a bean in the application context.
eg.) `@Component class MyUtility { /* ... */ }`

11.) What are `@Service`, `@Repository`, and `@Controller`?
ans.) These are specialized `@Component` annotations that provide additional semantic meaning and sometimes extra functionalities:
    - `@Service`: Indicates a class that performs business logic.
    - `@Repository`: Indicates a class that interacts with the database (provides data access). Spring also provides features like exception translation for classes marked with `@Repository`.
    - `@Controller`: Indicates a class that handles web requests (part of Spring MVC).

12.) What is `ApplicationContext`?
ans.) `ApplicationContext` is the central interface in Spring for providing configuration information to the application. It is the core of the Spring IoC container. It extends `BeanFactory` and provides more enterprise-specific functionalities like AOP capabilities, message resource handling, and event publication.

13.) What is Aspect-Oriented Programming (AOP)?
ans.) AOP is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns (e.g., logging, security, transaction management) from the core business logic.

14.) What are the key AOP terms?
ans.)
    - **Aspect:** A modularization of a cross-cutting concern (e.g., Logging Aspect).
    - **Join Point:** A specific point during the execution of a program (e.g., method execution, exception handling).
    - **Advice:** Action taken by an aspect at a particular join point (e.g., "log before method execution").
    - **Pointcut:** A predicate that matches join points where advice should be executed (e.g., "all methods in `com.example.service` package").
    - **Weaving:** The process of integrating aspects into the target objects to create the advised object.

15.) What are the different types of Advice in Spring AOP?
ans.)
    - **@Before:** Advice that runs before a join point.
    - **@AfterReturning:** Advice that runs after a join point completes successfully.
    - **@AfterThrowing:** Advice that runs if a join point exits by throwing an exception.
    - **@After (finally):** Advice that runs after a join point, regardless of its outcome.
    - **@Around:** Advice that surrounds a join point, allowing you to perform actions before and after the method call, and even prevent the method from executing.

16.) What is `@Bean` annotation?
ans.) The `@Bean` annotation is used in Java-based configuration (`@Configuration` classes) to declare a method that produces a bean to be managed by the Spring IoC container. The method name becomes the bean name by default.
eg.) `@Configuration class AppConfig { @Bean public MyService myService() { return new MyService(); } }`

17.) What is `@Configuration` annotation?
ans.) `@Configuration` is a class-level annotation that indicates that a class declares one or more `@Bean` methods. These methods are processed by the Spring container to generate bean definitions and service requests for those beans at runtime.

18.) What is the default scope of a Spring Bean?
ans.) The default scope for a Spring Bean is `singleton`. This means only one instance of the bean is created per Spring IoC container.

19.) What are the common Bean Scopes in Spring?
ans.)
    - **singleton (default):** Only one instance of the bean is created per Spring IoC container.
    - **prototype:** A new instance of the bean is created every time it is requested.
    - **request:** (Web-aware only) A new instance is created for each HTTP request.
    - **session:** (Web-aware only) A new instance is created for each HTTP session.
    - **application:** (Web-aware only) A single instance is created for the entire ServletContext lifetime.
    - **websocket:** (Web-aware only) A single instance for the lifecycle of a WebSocket.

20.) How do you specify the scope of a Spring Bean?
ans.) Using the `@Scope` annotation.
eg.) `@Component @Scope("prototype") class MyPrototypeBean { /* ... */ }`

21.) What is `@Value` annotation?
ans.) The `@Value` annotation is used to inject values from properties files, environment variables, or other sources directly into fields within Spring-managed beans.
eg.) `@Value("${app.name}") private String appName;`

22.) What is `BeanFactory`?
ans.) `BeanFactory` is the most basic interface for accessing a Spring IoC container. It provides basic functionalities like `getBean()`. `ApplicationContext` is a more advanced sub-interface.

23.) What is `Life Cycle of a Spring Bean`?
ans.) A Spring Bean goes through several phases:
    1.  **Instantiation:** The bean is instantiated.
    2.  **Populate properties:** Dependencies are injected (DI).
    3.  **Bean Name/Factory Aware:** If implemented, `setBeanName()` and `setBeanFactory()` are called.
    4.  **Application Context Aware:** If implemented, `setApplicationContext()` is called.
    5.  **Bean Post Processors (pre-initialization):** `postProcessBeforeInitialization()` is called.
    6.  **Initializing Bean:** If `afterPropertiesSet()` is implemented.
    7.  **Custom init method:** If specified by `@PostConstruct` or `init-method`.
    8.  **Bean Post Processors (post-initialization):** `postProcessAfterInitialization()` is called.
    9.  **Ready for use:** The bean is ready for use by the application.
    10. **Container Shutdown:** When the container shuts down.
    11. **Disposable Bean:** If `destroy()` is implemented.
    12. **Custom destroy method:** If specified by `@PreDestroy` or `destroy-method`.

24.) What are `BeanPostProcessor` and `BeanFactoryPostProcessor`?
ans.)
    - `BeanPostProcessor`: Allows you to customize new bean instances after they have been instantiated by the IoC container. It's invoked *after* the bean is instantiated and configured.
    - `BeanFactoryPostProcessor`: Operates on the bean *definition* (metadata) level before any bean instances are created. It allows you to modify the bean definitions themselves (e.g., change property values, add new bean definitions).

25.) What is Spring `Event Handling`?
ans.) Spring's event handling mechanism allows components to communicate with each other through events. A `publisher` sends an `ApplicationEvent`, and `listeners` (implementing `ApplicationListener`) can react to specific events.
eg.) `@Service class MyService { @Autowired private ApplicationEventPublisher eventPublisher; public void doSomething() { eventPublisher.publishEvent(new MyCustomEvent(this, "Data")); } }`

---

**Spring Boot**

26.) What is Spring Boot?
ans.) Spring Boot is an opinionated framework built on top of the Spring Framework that aims to simplify the development of production-ready, stand-alone, Spring-based applications. It focuses on convention over configuration, reducing boilerplate code and making it easier to get Spring applications up and running quickly.

27.) What are the main goals/advantages of Spring Boot?
ans.)
    - **Rapid Application Development (RAD):** Quick setup and development.
    - **Convention over Configuration:** Sensible defaults reduce configuration effort.
    - **Stand-alone applications:** Embedded web servers (Tomcat, Jetty, Undertow).
    - **No XML configuration:** Primarily uses annotations and Java config.
    - **Production-ready features:** Health checks, metrics, externalized configuration.
    - **Simplified Dependency Management:** Through starter dependencies.

28.) What is a `Spring Boot Starter`?
ans.) Spring Boot Starters are a set of convenient dependency descriptors that you can include in your project. They bundle common dependencies together, providing a "starter" for a particular functionality (e.g., `spring-boot-starter-web` for web apps, `spring-boot-starter-data-jpa` for JPA). This simplifies dependency management.
eg.) `<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency>`

29.) What is `Auto-configuration` in Spring Boot?
ans.) Auto-configuration is Spring Boot's core feature that automatically configures your Spring application based on the JARs present on your classpath and beans you've defined. For example, if you have `spring-webmvc` on the classpath, Spring Boot auto-configures DispatcherServlet.

30.) How does Spring Boot's `Auto-configuration` work internally?
ans.) Spring Boot uses `@Conditional` annotations (like `@ConditionalOnClass`, `@ConditionalOnMissingBean`) to make intelligent decisions about which configurations to apply. It checks for the presence of certain classes, beans, or properties before applying a specific auto-configuration.

31.) What is `@SpringBootApplication` annotation?
ans.) `@SpringBootApplication` is a convenient annotation that combines three commonly used Spring Boot annotations:
    - `@SpringBootConfiguration`: Marks a class as a Spring Boot configuration class.
    - `@EnableAutoConfiguration`: Enables Spring Boot's auto-configuration mechanism.
    - `@ComponentScan`: Enables component scanning to find and register Spring components (beans).
eg.) `@SpringBootApplication class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } }`

32.) How do you run a Spring Boot application?
ans.)
    1.  By executing the `main` method in the class annotated with `@SpringBootApplication`.
    2.  Using the `spring-boot:run` Maven goal or `bootRun` Gradle task.
    3.  As a standalone JAR (executable JAR) using `java -jar your-app.jar`.

33.) What is an `Embedded Server` in Spring Boot?
ans.) Spring Boot includes embedded web servers (like Tomcat, Jetty, or Undertow) by default. This means you don't need to deploy your application as a WAR file to a separate application server; the server is packaged directly within your executable JAR.

34.) How do you change the default port of a Spring Boot application?
ans.) You can configure the port in the `application.properties` or `application.yml` file:
eg.) `server.port=8081` (in `application.properties`)
eg.) `server:`
    `  port: 8081` (in `application.yml`)

35.) What is `application.properties` or `application.yml`?
ans.) These are externalized configuration files that Spring Boot automatically loads. They are used to configure various aspects of your application, such as database connections, server ports, logging levels, and custom properties. `application.yml` is preferred for its cleaner, YAML-based syntax.

36.) What is `Spring Actuator`?
ans.) Spring Boot Actuator provides production-ready features to monitor and manage your application. It offers various endpoints (e.g., `/health`, `/info`, `/metrics`, `/env`) that expose operational information about the running application.

37.) How do you enable and customize Actuator endpoints?
ans.) You enable and customize Actuator endpoints in `application.properties` or `application.yml`. For example, to expose all endpoints over web:
eg.) `management.endpoints.web.exposure.include=*`

38.) What are `Spring Profiles`?
ans.) Spring Profiles provide a way to separate parts of your application configuration and make it available only in certain environments (e.g., development, test, production). This allows you to use different configurations for different deployment environments without changing the code.

39.) How do you activate a Spring Profile?
ans.)
    1.  **Programmatically:** `SpringApplication.setAdditionalProfiles("dev")`.
    2.  **Environment variable:** `SPRING_PROFILES_ACTIVE=dev`.
    3.  **JVM argument:** `-Dspring.profiles.active=dev`.
    4.  **`application.properties`/`application.yml`:** `spring.profiles.active=dev`.

40.) What is the advantage of using Spring Boot over traditional Spring?
ans.)
    - Less boilerplate code and configuration (due to auto-config and starters).
    - Faster development and deployment cycle.
    - Embedded servers simplify deployment.
    - Production-ready features out-of-the-box (Actuator).
    - Opinionated defaults make initial setup easy.

41.) What is `SpringApplication.run()` method?
ans.) The `SpringApplication.run()` method is the main method that bootstraps a Spring Boot application. It creates an `ApplicationContext` and runs the embedded web server, starting your application.

42.) How does Spring Boot handle externalized configuration?
ans.) Spring Boot provides a flexible way to externalize configuration so you can work with the same application code in different environments. It loads properties from various sources in a specific order (e.g., command-line arguments, environment variables, `application.properties`/`yml`, profile-specific files).

43.) What are `DevTools` in Spring Boot?
ans.) Spring Boot DevTools is a set of tools that improve the development experience. It provides features like:
    - Automatic restart whenever files on the classpath change.
    - Automatic browser refresh when resources change.
    - Default template caching disabled for faster iterations.
    - LiveReload support.

44.) Can you exclude auto-configuration classes in Spring Boot?
ans.) Yes, you can exclude specific auto-configuration classes using the `exclude` attribute of `@EnableAutoConfiguration` or `@SpringBootApplication`.
eg.) `@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})`

45.) How to create a custom Spring Boot Starter?
ans.) You create a custom starter by creating a separate module that contains:
    1.  `META-INF/spring.factories` file that lists your auto-configuration classes.
    2.  Your custom auto-configuration classes (annotated with `@Configuration` and `@Conditional` annotations).
    3.  Any required dependencies.

46.) What is `@ConditionalOnProperty`?
ans.) `@ConditionalOnProperty` is an annotation that allows an auto-configuration class or a bean definition to be included only if a specific configuration property is present and has a particular value.
eg.) `@ConditionalOnProperty(name="feature.enabled", havingValue="true")`

47.) What is `Spring Boot @ControllerAdvice`?
ans.) `@ControllerAdvice` is a Spring annotation that allows you to define global exception handling, model attributes, and data binding across all `@Controller` classes in your application. It's often used with `@ExceptionHandler` for centralized error handling.

48.) What is `Spring Boot @RestControllerAdvice`?
ans.) `@RestControllerAdvice` is a specialization of `@ControllerAdvice` that's typically used for REST APIs. It implies `@ResponseBody` on its methods, so returned values are directly written to the HTTP response body (e.g., JSON error responses).

49.) What is the `Banner` in Spring Boot?
ans.) The banner is the text art that Spring Boot prints to the console when your application starts. You can customize it by adding a `banner.txt` file to your `src/main/resources` directory or by configuring properties.

50.) How to disable the default web server in Spring Boot?
ans.) You can disable the embedded web server by setting `spring.main.web-application-type=none` in `application.properties` or by excluding the web starter dependency. This is useful for building non-web applications like batch processes.

---

**Spring Web (MVC)**

51.) What is Spring MVC?
ans.) Spring MVC is a part of the Spring Framework that provides an architecture for building web applications following the Model-View-Controller (MVC) design pattern. It separates the application into distinct layers for handling user input, managing data, and presenting information.

52.) Explain the MVC design pattern.
ans.)
    - **Model:** Represents the application's data and business logic. It's independent of the user interface.
    - **View:** Responsible for presenting the data to the user. It's typically the UI (e.g., HTML, JSP).
    - **Controller:** Acts as an intermediary between the Model and View. It receives user input, processes it (potentially updating the Model), and then selects the appropriate View to display the Model's data.

53.) What is `DispatcherServlet`?
ans.) `DispatcherServlet` is the core of the Spring MVC framework. It acts as the front controller, receiving all incoming requests and delegating them to the appropriate handlers (controllers). It's responsible for managing the entire request processing workflow.

54.) What is `@Controller` annotation?
ans.) `@Controller` is a stereotype annotation that marks a class as a Spring MVC controller. It's responsible for handling incoming web requests and returning a view name or directly writing to the response body.

55.) What is `@RequestMapping` annotation?
ans.) `@RequestMapping` is used to map web requests to handler methods in Spring MVC controllers. It can be applied at the class level (for base URL) or method level (for specific endpoints).
eg.) `@RequestMapping("/users") public class UserController { @RequestMapping("/{id}") public String getUser(@PathVariable Long id) { return "user"; } }`

56.) What are `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, `@PatchMapping`?
ans.) These are shortcut annotations introduced in Spring 4.3 that are specializations of `@RequestMapping` for common HTTP methods:
    - `@GetMapping`: For HTTP GET requests.
    - `@PostMapping`: For HTTP POST requests.
    - `@PutMapping`: For HTTP PUT requests.
    - `@DeleteMapping`: For HTTP DELETE requests.
    - `@PatchMapping`: For HTTP PATCH requests.
eg.) `@GetMapping("/products") public List<Product> getAllProducts() { /* ... */ }`

57.) What is `@RequestParam`?
ans.) `@RequestParam` is used to bind query parameters from the URL to a method parameter in a Spring MVC controller.
eg.) `@GetMapping("/search") public String search(@RequestParam String query) { /* ... */ }`
    // URL: /search?query=laptop

58.) What is `@PathVariable`?
ans.) `@PathVariable` is used to bind URI template variables (path variables) from the URL to a method parameter in a Spring MVC controller.
eg.) `@GetMapping("/users/{id}") public User getUser(@PathVariable Long id) { /* ... */ }`
    // URL: /users/123

59.) What is `@RequestBody`?
ans.) `@RequestBody` is used to bind the HTTP request body (e.g., JSON or XML content) to a method parameter. Spring uses HTTP Message Converters to convert the incoming body into a Java object.
eg.) `@PostMapping("/users") public User createUser(@RequestBody User newUser) { /* ... */ }`

60.) What is `@ResponseBody`?
ans.) `@ResponseBody` annotation indicates that the return value of a controller method should be directly bound to the web response body. It's typically used in REST APIs to return data (like JSON or XML) instead of a view name. `RestController` automatically applies this.
eg.) `@GetMapping("/api/data") @ResponseBody public String getData() { return "some data"; }`

61.) What is `ModelAndView`?
ans.) `ModelAndView` is a class in Spring MVC that holds both the model data and the view name. A controller can return a `ModelAndView` object to the `DispatcherServlet`, which then resolves the view and renders it with the model data. (More common with traditional web apps, less with REST).
eg.) `ModelAndView mav = new ModelAndView("welcome"); mav.addObject("name", "Spring"); return mav;`

62.) How does Spring MVC handle form submissions?
ans.) Spring MVC uses data binding to automatically bind form data to Java objects (command objects or form beans). Annotations like `@ModelAttribute` are used for this. Validation can be performed using JSR 303 Bean Validation.

63.) What is `InternalResourceViewResolver`?
ans.) `InternalResourceViewResolver` is a `ViewResolver` implementation in Spring MVC that resolves view names to actual resources (like JSPs) within the web application's `WEB-INF` directory. It helps define prefixes and suffixes for view names.
eg.) `prefix=/WEB-INF/views/`, `suffix=.jsp` for view name "home".

64.) What are `Filters` and `Interceptors` in Spring MVC?
ans.)
    - **Filters (Servlet Filter):** Part of the Servlet specification. They are executed by the servlet container (e.g., Tomcat) *before* `DispatcherServlet`. They can inspect and modify requests/responses (e.g., logging, authentication, character encoding).
    - **Interceptors (Spring HandlerInterceptor):** Part of Spring MVC. They are executed *after* `DispatcherServlet` but *before* the handler method. They provide more fine-grained control over the request processing lifecycle (e.g., pre-handling, post-handling, after completion).

65.) When would you use a Filter versus an Interceptor?
ans.)
    - **Filter:** Use for broad concerns that apply to all incoming requests before Spring MVC processes them (e.g., authentication on every request, URL rewriting, GZIP compression).
    - **Interceptor:** Use for Spring MVC-specific concerns that need access to Spring's `ApplicationContext` or Handler (e.g., logging method execution times, checking user roles for specific controllers).

---

**Spring Data JPA**

66.) What is Spring Data JPA?
ans.) Spring Data JPA is part of the Spring Data family. It aims to significantly improve the implementation of data access layers by providing a high-level abstraction over JPA (Java Persistence API). It greatly reduces the boilerplate code required for implementing data access object (DAO) layers.

67.) What is JPA?
ans.) JPA (Java Persistence API) is a Java specification for managing relational data in applications using Java Persistence API entities. It provides an ORM (Object-Relational Mapping) approach, mapping Java objects to database tables and vice-versa. Hibernate is a popular implementation of JPA.

68.) What is `ORM`?
ans.) ORM (Object-Relational Mapping) is a programming technique that maps an object model to a relational database. It allows developers to work with database entities as objects, simplifying database interactions and reducing SQL code.

69.) What is a `Repository` in Spring Data JPA?
ans.) In Spring Data JPA, a `Repository` is an interface that acts as a bridge between your application and the database. By extending Spring Data JPA's provided repository interfaces (like `CrudRepository` or `JpaRepository`), you automatically get common CRUD (Create, Read, Update, Delete) operations without writing any implementation code.

70.) What is `CrudRepository`?
ans.) `CrudRepository` is a Spring Data JPA interface that provides basic CRUD operations: `save()`, `findById()`, `findAll()`, `delete()`, `count()`, etc. It's a convenient starting point for most data access needs.

71.) What is `JpaRepository`?
ans.) `JpaRepository` extends `PagingAndSortingRepository` which in turn extends `CrudRepository`. It provides all CRUD operations plus additional JPA-specific methods like flushing, batch deletion, and methods for pagination and sorting. It's generally the preferred interface for most applications.

72.) What is `@Entity` annotation?
ans.) `@Entity` is a JPA annotation that marks a Java class as an entity, meaning it represents a table in a relational database. Instances of this class will correspond to rows in that table.
eg.) `@Entity class Product { /* ... */ }`

73.) What is `@Id` annotation?
ans.) `@Id` is a JPA annotation that designates a field as the primary key of an entity. Every entity must have a primary key.
eg.) `@Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id;`

74.) What is `@GeneratedValue`?
ans.) `@GeneratedValue` is a JPA annotation used with `@Id` to specify that the primary key value will be automatically generated by the database. Common strategies include `IDENTITY` (auto-increment column), `SEQUENCE` (database sequence), `TABLE` (separate table to store ID), and `AUTO` (ORM chooses).

75.) What is `@Table` annotation?
ans.) `@Table` is a JPA annotation used to specify the primary table for the annotated entity. You can specify the table name, schema, and unique constraints. If omitted, the table name defaults to the entity class name.
eg.) `@Entity @Table(name = "products") class Product { /* ... */ }`

76.) What is `@Column` annotation?
ans.) `@Column` is a JPA annotation used to specify the mapped column for a persistent property or field. You can specify the column name, length, nullability, etc. If omitted, the column name defaults to the field name.
eg.) `@Column(name = "product_name", nullable = false, length = 100) private String name;`

77.) How do you define custom queries in Spring Data JPA?
ans.) Spring Data JPA allows you to define custom queries in several ways:
    1.  **Method Name Conventions:** By defining methods with specific names that Spring Data JPA can parse into queries (e.g., `findByLastNameAndFirstName`).
    2.  **`@Query` annotation:** By writing JPQL (Java Persistence Query Language) or native SQL queries directly within the method.
    3.  **Derived Queries:** By using `Specification` or `Querydsl`.

78.) Give an example of a query derived from a method name.
ans.)
eg.) `interface UserRepository extends JpaRepository<User, Long> {`
    `  List<User> findByEmail(String email);`
    `  List<User> findByAgeGreaterThan(int age);`
    `  List<User> findByLastNameContainingOrderByFirstNameAsc(String lastName);`
    `}`

79.) Give an example of using `@Query` annotation.
ans.)
eg.) `interface UserRepository extends JpaRepository<User, Long> {`
    `  @Query("SELECT u FROM User u WHERE u.email = ?1")`
    `  User findUserByEmailAddress(String email);`
    `  @Query(value = "SELECT * FROM users WHERE status = :status", nativeQuery = true)`
    `  List<User> findUsersByStatusNative(@Param("status") String status);`
    `}`

80.) What is the purpose of `@Transactional` annotation?
ans.) `@Transactional` is a Spring annotation that defines the scope of a single database transaction. When applied to a method or class, Spring automatically manages the transaction: starting it before the method executes and committing/rolling back after it completes, based on success or failure.
eg.) `@Transactional public void saveUser(User user) { userRepository.save(user); }`

81.) Explain `@OneToMany` and `@ManyToOne` relationships.
ans.) These annotations define relationships between entities:
    - **`@OneToMany`:** A single entity on one side is related to multiple entities on the other side.
        eg.) One `Department` has Many `Employees`. (Department side: `@OneToMany`)
    - **`@ManyToOne`:** Multiple entities on one side are related to a single entity on the other side.
        eg.) Many `Employees` belong to One `Department`. (Employee side: `@ManyToOne`)

82.) What is the difference between `LAZY` and `EAGER` fetching?
ans.)
    - **EAGER:** When the main entity is loaded, all its associated related entities are also loaded immediately. This can lead to fetching more data than needed (N+1 query problem).
    - **LAZY (default for collections):** Related entities are loaded only when they are explicitly accessed for the first time. This saves resources but can lead to `LazyInitializationException` if accessed outside a transaction.

83.) How do you handle `LazyInitializationException`?
ans.)
    - Ensure the session/transaction is open when accessing lazy-loaded collections/entities (e.g., keep method `@Transactional`).
    - Use `JOIN FETCH` in JPQL queries to eagerly fetch specific associations.
    - Change fetch type to `EAGER` (use with caution, can cause performance issues).
    - Use `Hibernate.initialize()` to force loading within the session.

84.) What is `PagingAndSortingRepository`?
ans.) `PagingAndSortingRepository` extends `CrudRepository` and adds methods for pagination (`findAll(Pageable pageable)`) and sorting (`findAll(Sort sort)`). `JpaRepository` extends this.

85.) What are `JPQL` and `Native SQL` queries in Spring Data JPA?
ans.)
    - **JPQL (Java Persistence Query Language):** An object-oriented query language defined by the JPA specification. It operates on entities and their relationships, not directly on database tables. It's database-agnostic.
    - **Native SQL:** Allows you to write raw SQL queries directly in your `@Query` annotations. This is useful for complex, database-specific queries that cannot be easily expressed in JPQL. You must set `nativeQuery = true`.

---

**Spring REST**

86.) What is REST?
ans.) REST (Representational State Transfer) is an architectural style for designing networked applications. It's an approach to communications between distributed systems that uses standard HTTP methods (GET, POST, PUT, DELETE, PATCH) to interact with resources.

87.) What is a `RESTful Web Service`?
ans.) A RESTful web service is a web service implemented using the REST architectural style. It exposes resources (like users, products) through unique URIs, and allows clients to perform operations on these resources using standard HTTP methods.

88.) What is `@RestController` annotation?
ans.) `@RestController` is a convenient annotation introduced in Spring 4.0 that combines `@Controller` and `@ResponseBody`. It means every method in the controller returns data directly (e.g., JSON or XML) instead of a view name, making it ideal for building REST APIs.
eg.) `@RestController class UserRestController { /* ... */ }`

89.) What are the common HTTP methods used in REST APIs?
ans.)
    - **GET:** Retrieve a resource or a collection of resources. (Idempotent and safe).
    - **POST:** Create a new resource. (Not idempotent, not safe).
    - **PUT:** Update an existing resource (full replacement). (Idempotent).
    - **DELETE:** Remove a resource. (Idempotent).
    - **PATCH:** Partially update an existing resource. (Not idempotent).

90.) What is the concept of `statelessness` in REST?
ans.) Statelessness means that each request from a client to a server must contain all the information needed to understand the request. The server should not store any client context between requests. This improves scalability and reliability.

91.) What is `@RequestBody` used for in REST controllers?
ans.) `@RequestBody` is used to bind the HTTP request body (e.g., JSON payload sent by a client) to a Java object parameter in a REST controller method. Spring automatically converts the JSON/XML into the specified Java object using message converters.
eg.) `@PostMapping("/users") public ResponseEntity<User> createUser(@RequestBody User user) { /* ... */ }`

92.) What is `@ResponseBody` used for in REST controllers?
ans.) `@ResponseBody` indicates that the return value of a controller method should be directly bound to the web response body. Spring uses message converters to convert the Java object into a suitable format (e.g., JSON) and sends it as the response. (Implicitly included with `@RestController`).

93.) What is `ResponseEntity`?
ans.) `ResponseEntity` is a class in Spring that represents the entire HTTP response: status code, headers, and body. It gives you full control over the HTTP response that's sent back to the client.
eg.) `return new ResponseEntity<>(user, HttpStatus.CREATED);`

94.) How do you handle exceptions in Spring REST APIs?
ans.)
    - **`@ExceptionHandler`:** Method-level annotation to handle specific exceptions within a single controller.
    - **`@ControllerAdvice` / `@RestControllerAdvice`:** Class-level annotation for global exception handling across multiple controllers.
    - **`ResponseStatusException`:** Programmatically throw exceptions with specific HTTP status codes.
    - **Custom exception classes:** Define your own exceptions and map them to HTTP status codes.

95.) What is `HATEOAS`?
ans.) HATEOAS (Hypermedia As The Engine Of Application State) is a constraint of the REST architectural style where a client interacts with a server solely through hypermedia dynamically provided by the server. Instead of having hardcoded URLs, the server response includes links that the client can follow for further actions, making the API more discoverable and flexible.

96.) What is `CORS` and how do you handle it in Spring Boot?
ans.) CORS (Cross-Origin Resource Sharing) is a security mechanism that allows web browsers to make requests to a domain different from the one serving the original webpage. By default, browsers prevent cross-origin requests for security reasons.
In Spring Boot, you can handle CORS using:
    - `@CrossOrigin` annotation on controller classes or methods.
    - Global CORS configuration using a `WebMvcConfigurer` bean.
eg.) `@CrossOrigin(origins = "http://localhost:3000") @RestController public class MyController { /* ... */ }`

97.) What are `HTTP status codes` and why are they important in REST?
ans.) HTTP status codes are standard numerical codes returned by a server in response to a client's request. They indicate the outcome of the request (e.g., success, client error, server error). They are crucial in REST for communicating the state and result of an operation to the client in a standardized way.
eg.) `200 OK`, `201 Created`, `400 Bad Request`, `401 Unauthorized`, `404 Not Found`, `500 Internal Server Error`.

98.) How do you implement `versioning` in REST APIs?
ans.) Versioning is important to evolve APIs without breaking existing clients. Common strategies:
    - **URI Versioning:** `GET /api/v1/users`
    - **Query Parameter Versioning:** `GET /api/users?version=1`
    - **Header Versioning:** Custom `X-Api-Version` header.
    - **Content Negotiation (Accept Header):** `Accept: application/vnd.company.app-v1+json`

99.) What is `Idempotence` in REST API?
ans.) An HTTP method is idempotent if an identical request can be made multiple times without changing the state of the server beyond the initial request.
    - **Idempotent:** GET, PUT, DELETE, HEAD, OPTIONS, TRACE
    - **Not Idempotent:** POST (each request creates a new resource)

100.) What is the purpose of `Content-Type` header in REST?
ans.) The `Content-Type` header indicates the media type of the resource in the request or response body. It tells the server what type of data the client is sending (for requests) and tells the client what type of data the server is sending (for responses).
eg.) `Content-Type: application/json`

---

**Spring Security**

101.) What is Spring Security?
ans.) Spring Security is a powerful and highly customizable authentication and access-control framework that provides robust security features for Spring-based applications. It focuses on providing both authentication (who are you?) and authorization (what can you do?).

102.) What are `Authentication` and `Authorization`?
ans.)
    - **Authentication:** The process of verifying the identity of a user (or system). It answers the question "Who are you?". (e.g., username/password).
    - **Authorization:** The process of determining if an authenticated user has permission to access a specific resource or perform a specific action. It answers the question "What are you allowed to do?".

103.) What are the main components of Spring Security's architecture?
ans.)
    - **`SecurityContextHolder`:** Stores the details of the security context, including the `Authentication` object.
    - **`Authentication`:** Represents the currently authenticated principal (user).
    - **`AuthenticationManager`:** Processes an `Authentication` request.
    - **`ProviderManager`:** A common implementation of `AuthenticationManager` that delegates to `AuthenticationProviders`.
    - **`AuthenticationProvider`:** Performs the actual authentication (e.g., `DaoAuthenticationProvider` for database).
    - **`UserDetailsService`:** Used by `DaoAuthenticationProvider` to load user-specific data by username.
    - **`PasswordEncoder`:** Used to encode and decode passwords.
    - **`AccessDecisionManager`:** Determines if a user has permission to access a resource based on granted authorities.
    - **`Filter Chain`:** A series of `Filters` that handle security concerns (e.g., `UsernamePasswordAuthenticationFilter`).

104.) What is `UserDetailsService`?
ans.) `UserDetailsService` is a core interface in Spring Security. It has one method, `loadUserByUsername()`, which is responsible for fetching user details (username, password, roles/authorities) from a data source (e.g., database, LDAP) and wrapping them in a `UserDetails` object.
eg.) `@Service public class CustomUserDetailsService implements UserDetailsService { /* ... */ }`

105.) What is `PasswordEncoder`?
ans.) `PasswordEncoder` is an interface used to perform one-way (hashing) transformations of passwords. Spring Security requires a `PasswordEncoder` to store and compare passwords securely. `BCryptPasswordEncoder` is a popular implementation.
eg.) `@Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }`

106.) How do you configure HTTP Basic Authentication in Spring Security?
ans.) In a `SecurityFilterChain` (or `WebSecurityConfigurerAdapter` in older Spring Security):
eg.) `@Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {`
    `  http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())`
    `      .httpBasic(Customizer.withDefaults());`
    `  return http.build();`
    `}`

107.) How do you configure form-based authentication?
ans.) In a `SecurityFilterChain`:
eg.) `@Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {`
    `  http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated())`
    `      .formLogin(Customizer.withDefaults()); // Or .formLogin().loginPage("/login").permitAll()`
    `  return http.build();`
    `}`

108.) How do you secure specific URLs with roles/authorities?
ans.) Using `authorizeHttpRequests()` in your `SecurityFilterChain` configuration:
eg.) `http.authorizeHttpRequests(auth -> auth`
    `  .requestMatchers("/admin/**").hasRole("ADMIN")`
    `  .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")`
    `  .anyRequest().authenticated()`
    `);`

109.) What is `@PreAuthorize` and `@PostAuthorize`?
ans.) These are method-level security annotations from Spring Security's expression-based access control:
    - `@PreAuthorize`: Checks a security expression *before* the method execution. If the expression evaluates to `false`, the method is not executed, and an `AccessDeniedException` is thrown.
    - `@PostAuthorize`: Checks a security expression *after* the method execution, but before the result is returned to the caller. The method would have already run.
eg.) `@PreAuthorize("hasRole('ADMIN')") public String deleteUser(Long id) { /* ... */ }`

110.) What is `@Secured` annotation?
ans.) `@Secured` is a simpler annotation for method-level security. It takes a list of roles (as strings) that are required to access the method. It's less flexible than `@PreAuthorize` as it doesn't support complex SpEL expressions.
eg.) `@Secured("ROLE_ADMIN") public String deleteUser(Long id) { /* ... */ }`

111.) What is `CSRF` protection in Spring Security?
ans.) CSRF (Cross-Site Request Forgery) is a type of attack where a malicious website tricks a user's browser into performing an unwanted action on a trusted site where the user is currently authenticated. Spring Security provides built-in CSRF protection by requiring a CSRF token in non-GET requests.

112.) How does Spring Security handle `session management`?
ans.) Spring Security can manage user sessions, including:
    - **Session fixation protection:** Prevents attackers from using a fixed session ID.
    - **Session concurrency control:** Limits the number of concurrent sessions for a user.
    - **Session expiration/invalidation:** Configurable session timeouts.

113.) What is `OAuth2` in Spring Security?
ans.) Spring Security provides comprehensive support for OAuth2, an authorization framework. It allows users to grant third-party applications limited access to their resources (e.g., social media profiles) without sharing their credentials directly. Spring Security can act as an OAuth2 client, resource server, or authorization server.

114.) What is `JWT` (JSON Web Token)?
ans.) JWT is a compact, URL-safe means of representing claims to be transferred between two parties. It's often used for authentication in stateless REST APIs. A JWT contains a header, a payload (claims), and a signature. Spring Security can be configured to use JWT for authentication.

115.) How can you disable CSRF in Spring Security?
ans.) You can disable CSRF protection in your `SecurityFilterChain` configuration. This is sometimes done for stateless REST APIs that use token-based authentication (like JWT), but generally, it's recommended to keep it enabled for browser-based applications.
eg.) `http.csrf(csrf -> csrf.disable());`

---

**Microservices (Spring Context)**

116.) What are Microservices?
ans.) Microservices are an architectural style that structures an application as a collection of loosely coupled, independently deployable services. Each service is self-contained, focuses on a single business capability, and communicates with others via lightweight mechanisms (like HTTP APIs).

117.) What are the main characteristics of a Microservices architecture?
ans.)
    - **Decentralized:** No central database or monolithic deployment.
    - **Loosely Coupled:** Services communicate via APIs, minimizing dependencies.
    - **Independent Deployment:** Services can be deployed and updated independently.
    - **Small and Focused:** Each service handles a single business capability.
    - **Polyglot Persistence/Programming:** Services can use different technologies.
    - **Resilience:** Failure in one service doesn't necessarily bring down the whole system.

118.) What are the challenges of Microservices?
ans.)
    - **Complexity:** Distributed systems are inherently more complex to design, develop, test, and operate.
    - **Data Consistency:** Maintaining data consistency across multiple databases.
    - **Inter-service Communication:** Managing network calls, latency, and fault tolerance.
    - **Distributed Transactions:** Handling transactions across multiple services.
    - **Monitoring & Logging:** Centralized logging and monitoring become critical.
    - **Deployment Complexity:** More services mean more deployments.

119.) How does Spring Boot facilitate Microservices development?
ans.) Spring Boot simplifies microservices development by:
    - Rapid application development for individual services.
    - Embedded servers for easy packaging and deployment.
    - Actuator for monitoring.
    - Integration with Spring Cloud for common microservice patterns.

120.) What is Spring Cloud?
ans.) Spring Cloud is a collection of projects that provide tools for building common patterns in distributed systems (microservices). It offers solutions for service discovery, circuit breakers, distributed configuration, API gateways, load balancing, etc.

121.) What is `Service Discovery` and why is it needed in Microservices?
ans.) Service Discovery is a mechanism for services to find and communicate with each other without hardcoding their network locations (IP addresses and ports). In a dynamic microservices environment where instances scale up/down, service discovery is crucial for services to locate their dependencies automatically.

122.) Name a common Service Discovery implementation in Spring Cloud.
ans.) **Eureka (Netflix Eureka)** is a popular service discovery server/client provided by Netflix and integrated with Spring Cloud. Services register themselves with Eureka, and clients can discover registered services.

123.) What is a `Circuit Breaker` and why is it used?
ans.) A Circuit Breaker is a fault tolerance pattern used in distributed systems. When a service call repeatedly fails, the circuit breaker "trips," preventing further calls to that failing service for a period, diverting requests to a fallback mechanism, thus preventing cascading failures in the system.

124.) Name a common Circuit Breaker implementation in Spring Cloud.
ans.) **Resilience4j** is a lightweight, easy-to-use fault tolerance library that Spring Cloud integrates with. Before that, Hystrix was commonly used, but it's now in maintenance mode.

125.) What is an `API Gateway`?
ans.) An API Gateway is a single entry point for all clients consuming microservices. It handles common concerns like routing requests to appropriate services, authentication/authorization, rate limiting, monitoring, and potentially request aggregation.
eg.) **Spring Cloud Gateway** or **Netflix Zuul**.

126.) What is `Distributed Configuration`?
ans.) Distributed Configuration allows you to manage application configuration properties externally, across multiple services and environments, from a central location. This avoids having to redeploy services just to change configuration.
eg.) **Spring Cloud Config Server**.

127.) What is `Load Balancing` in Microservices?
ans.) Load balancing is the process of distributing network traffic among multiple servers to ensure no single server becomes a bottleneck. In microservices, it helps distribute requests among multiple instances of the same service to improve performance and availability.

128.) Name a common client-side Load Balancer in Spring Cloud.
ans.) **Spring Cloud LoadBalancer** (successor to Netflix Ribbon). It works with service discovery to distribute requests among available service instances.

129.) What is `Messaging` in Microservices and why is it used?
ans.) Messaging (using message queues like RabbitMQ, Kafka, or ActiveMQ) provides an asynchronous, decoupled communication mechanism between microservices. It's used for:
    - **Event-driven architectures:** Services publish events, others subscribe.
    - **Decoupling:** Services don't need to know about each other directly.
    - **Resilience:** Messages are queued, so services can process them even if the consumer is temporarily down.
    - **Scalability:** Consumers can be scaled independently.

130.) What are the challenges of `Distributed Transactions` in Microservices?
ans.) Distributed transactions (e.g., ensuring consistency across multiple services when one business operation involves updates in different services) are complex. Traditional two-phase commit (2PC) is often too slow and restrictive. Alternative patterns like **Saga pattern** or **eventual consistency** are used.

---

**Bonus Questions / Expanding on Concepts**

131.) What is the `Dependency Inversion Principle` (DIP) and how does Spring help achieve it?
ans.) DIP states that high-level modules should not depend on low-level modules; both should depend on abstractions. Also, abstractions should not depend on details; details should depend on abstractions. Spring helps achieve this through Dependency Injection, where concrete implementations are injected via interfaces (abstractions), rather than directly instantiating concrete classes.

132.) What is the purpose of `profiles` in `application.yml`?
ans.) You can create profile-specific configuration files like `application-dev.yml`, `application-prod.yml`. When a profile (e.g., `dev`) is active, Spring Boot loads properties from `application.yml` and then overrides them with properties from `application-dev.yml`.

133.) What is `Spring @Qualifier` annotation?
ans.) `@Qualifier` is used with `@Autowired` when there are multiple beans of the same type in the Spring IoC container. It allows you to specify which particular bean should be injected, by its name or a custom qualifier value.
eg.) `@Autowired @Qualifier("primaryService") private MyService myService;`

134.) What is `Lombok` and how is it useful in Spring projects?
ans.) Lombok is a Java library that plugs into the build process and automatically generates boilerplate code (like getters, setters, constructors, equals, hashCode, toString) based on annotations. It reduces verbose code in POJOs (Plain Old Java Objects) and entities, making code cleaner and more readable in Spring projects.
eg.) `@Data @NoArgsConstructor @AllArgsConstructor class User { private Long id; private String name; }`

135.) What is `Swagger/OpenAPI` and how is it used in Spring Boot?
ans.) Swagger/OpenAPI is a set of tools and specifications for designing, building, documenting, and consuming REST APIs. It allows you to generate interactive API documentation directly from your Spring Boot code using libraries like Springdoc OpenAPI or Springfox, making it easy for developers to understand and test your APIs.

136.) Explain `Unit Testing` vs `Integration Testing` in Spring Boot.
ans.)
    - **Unit Testing:** Tests individual components (e.g., a service method, a reducer) in isolation, mocking dependencies. Focuses on correctness of small units of code. Fast execution.
    - **Integration Testing:** Tests the interaction between multiple components or layers of the application (e.g., a controller calling a service, which calls a repository). Involves more of the Spring context and potentially a real database. Slower execution.

137.) What annotations are commonly used for `Unit Testing` in Spring Boot?
ans.)
    - `@ExtendWith(MockitoExtension.class)` (or `@RunWith(MockitoJUnitRunner.class)`) for Mockito.
    - `@Mock`: To create mock objects.
    - `@InjectMocks`: To inject mocks into the test class instance.
    - `@Captor`: To capture arguments passed to mocks.

138.) What annotations are commonly used for `Integration Testing` in Spring Boot?
ans.)
    - `@SpringBootTest`: Loads the full Spring application context.
    - `@AutoConfigureMockMvc`: Configures `MockMvc` for testing web layers.
    - `@WebMvcTest`: Focuses on testing the web layer (controllers), mocking other layers.
    - `@DataJpaTest`: Focuses on testing JPA components, setting up an in-memory database.
    - `@MockBean`: To create a mock and add it to the Spring application context.

139.) What is `Spring Boot DevTools` good for?
ans.) It dramatically speeds up development by providing features like:
    - Automatic restart of the application on code changes.
    - LiveReload for browser refresh.
    - Disabling template caching.
    - Remote debugging.

140.) How do you handle `validation` in Spring Boot REST APIs?
ans.) You typically use JSR 303 (Bean Validation API) annotations (e.g., `@NotNull`, `@Size`, `@Email`) on your DTOs (Data Transfer Objects) or entity fields. Then, in your controller, you add `@Valid` before the `@RequestBody` parameter to trigger validation. Spring's `MethodArgumentNotValidException` can be caught by `@ControllerAdvice` to return appropriate HTTP 400 responses.
eg.) `class UserDto { @NotNull private String name; @Email private String email; }`
    `@PostMapping public ResponseEntity<User> createUser(@Valid @RequestBody UserDto userDto) { /* ... */ }`

141.) What is `Thymeleaf`?
ans.) Thymeleaf is a server-side Java template engine for web and standalone environments. It's a popular choice for view layer in Spring MVC/Boot applications, offering natural templating (templates can be directly opened in browsers) and powerful features.

142.) What is the purpose of `Spring JPA Auditing`?
ans.) Spring JPA Auditing provides a way to automatically populate fields like `createdBy`, `createdDate`, `lastModifiedBy`, and `lastModifiedDate` in your entities. You enable it with `@EnableJpaAuditing` and use `@CreatedBy`, `@CreatedDate`, `@LastModifiedBy`, `@LastModifiedDate` on entity fields.

143.) What is a `DTO` (Data Transfer Object) in the context of REST APIs?
ans.) A DTO is a plain Java object that is used to transfer data between different layers of an application, especially between the client and the server in REST APIs. They often represent a subset or combination of fields from an entity, tailored for a specific API endpoint's input or output. This decouples the API contract from the internal database entity structure.

144.) What is `pagination` and how is it implemented with Spring Data JPA?
ans.) Pagination is the process of dividing a large set of data into smaller, discrete pages. Spring Data JPA makes it easy by using the `Pageable` interface. Repository methods can accept a `Pageable` object (containing page number, size, and sort information) and return a `Page<T>` object.
eg.) `interface ProductRepository extends JpaRepository<Product, Long> {`
    `  Page<Product> findAll(Pageable pageable);`
    `}`
    `// In service: Pageable pageable = PageRequest.of(0, 10, Sort.by("name"));`

145.) What is `Swagger UI`?
ans.) Swagger UI is a tool that renders OpenAPI specifications into interactive API documentation that developers can explore and test directly in their browsers. It's often integrated with Spring Boot applications to provide self-documenting APIs.

146.) How can you handle `cross-cutting concerns` without AOP?
ans.) Without AOP, cross-cutting concerns would typically be handled by:
    - **Duplicating code:** Copying logging, security checks into every method.
    - **Inheritance:** Creating a base class for common behavior (can lead to class hierarchy issues).
    - **Delegation:** Having utility classes that methods explicitly call.
    AOP provides a more elegant and modular solution.

147.) What is `Spring Expression Language (SpEL)`?
ans.) SpEL is a powerful expression language that supports querying and manipulating an object graph at runtime. It's used in various places within Spring, including annotations (`@Value`, `@PreAuthorize`), XML configuration, and more.
eg.) `@Value("#{systemProperties['java.home']}") private String javaHome;`

148.) What is the difference between `Spring IoC` and `Application Context`?
ans.) Spring IoC is the core principle/container that manages object creation and dependencies. `ApplicationContext` is the *interface* that represents the IoC container. It provides more enterprise-specific functionalities beyond basic bean management provided by `BeanFactory`. So, `ApplicationContext` is an advanced form of the Spring IoC container.

149.) How do you configure `custom properties` in Spring Boot?
ans.)
    1.  In `application.properties` or `application.yml`: `my.custom.property=hello`
    2.  Using `@ConfigurationProperties` to bind properties to a Java POJO.
    3.  Using `@Value` annotation to inject individual properties.

150.) What is the `fail-fast` principle in microservices?
ans.) The fail-fast principle suggests that a system should detect failures as early as possible and fail immediately rather than continuing in a potentially corrupted state. In microservices, this can involve quick timeouts, immediate error responses, and proper circuit breaker configurations to prevent a small failure from cascading through the entire system.
```